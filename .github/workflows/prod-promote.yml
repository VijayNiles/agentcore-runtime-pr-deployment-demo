name: Production Promotion

on:
  # Primary trigger: IssueOps pattern - add 'approved' label to deployment issue
  issues:
    types: [labeled]
  
  # Backup trigger: Manual workflow dispatch for emergency/testing
  workflow_dispatch:
    inputs:
      prod_runtime_version:
        description: 'Production version number to promote'
        required: true
        type: string
      pr_runtime_id:
        description: 'PR runtime ID to cleanup (optional - leave empty to skip cleanup)'
        required: false
        type: string
      issue_number:
        description: 'Issue number to update after promotion (optional)'
        required: false
        type: string

permissions:
  id-token: write  # Required for OIDC authentication
  contents: read
  issues: write
  pull-requests: write

jobs:
  promote:
    runs-on: ubuntu-latest
    # Only run for approved deployment issues OR manual workflow dispatch
    if: |
      (github.event_name == 'issues' && 
       github.event.label.name == 'approved' && 
       contains(github.event.issue.labels.*.name, 'needs-promotion')) ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::788835021449:role/GitHub-Actions-Role
          aws-region: us-west-2
      
      - name: Parse deployment metadata from issue
        if: github.event_name == 'issues'
        id: parse_issue
        uses: actions/github-script@v7
        with:
          script: |
            const issueBody = context.payload.issue.body;
            
            // Extract metadata from hidden HTML comment
            const metadataMatch = issueBody.match(/<!-- DEPLOYMENT_METADATA\s+([\s\S]*?)\s+-->/);
            if (!metadataMatch) {
              core.setFailed('Could not find deployment metadata in issue. Issue may not be a valid deployment issue.');
              return;
            }
            
            const metadata = metadataMatch[1];
            
            // Parse each field
            const runtimeIdMatch = metadata.match(/RUNTIME_ID:\s*(\S+)/);
            const versionMatch = metadata.match(/VERSION:\s*(\S+)/);
            const prRuntimeIdMatch = metadata.match(/PR_RUNTIME_ID:\s*(\S+)/);
            
            if (!runtimeIdMatch || !versionMatch) {
              core.setFailed('Invalid metadata format in deployment issue.');
              return;
            }
            
            const runtimeId = runtimeIdMatch[1];
            const version = versionMatch[1];
            const prRuntimeId = prRuntimeIdMatch ? prRuntimeIdMatch[1] : '';
            
            // Set outputs
            core.setOutput('runtime_id', runtimeId);
            core.setOutput('version', version);
            core.setOutput('pr_runtime_id', prRuntimeId === 'NONE' ? '' : prRuntimeId);
            core.setOutput('issue_number', context.payload.issue.number.toString());
            
            console.log(`Parsed from issue #${context.payload.issue.number}:`);
            console.log(`  Runtime ID: ${runtimeId}`);
            console.log(`  Version: ${version}`);
            console.log(`  PR Runtime ID: ${prRuntimeId}`);
      
      - name: Set variables for manual trigger
        if: github.event_name == 'workflow_dispatch'
        id: manual_inputs
        run: |
          echo "runtime_id=" >> $GITHUB_OUTPUT
          echo "version=${{ github.event.inputs.prod_runtime_version }}" >> $GITHUB_OUTPUT
          echo "pr_runtime_id=${{ github.event.inputs.pr_runtime_id }}" >> $GITHUB_OUTPUT
          echo "issue_number=${{ github.event.inputs.issue_number }}" >> $GITHUB_OUTPUT
      
      - name: Merge inputs from both trigger types
        id: inputs
        run: |
          if [ "${{ github.event_name }}" == "issues" ]; then
            echo "runtime_id=${{ steps.parse_issue.outputs.runtime_id }}" >> $GITHUB_OUTPUT
            echo "version=${{ steps.parse_issue.outputs.version }}" >> $GITHUB_OUTPUT
            echo "pr_runtime_id=${{ steps.parse_issue.outputs.pr_runtime_id }}" >> $GITHUB_OUTPUT
            echo "issue_number=${{ steps.parse_issue.outputs.issue_number }}" >> $GITHUB_OUTPUT
            echo "trigger_type=IssueOps (approved label)" >> $GITHUB_OUTPUT
          else
            echo "runtime_id=${{ steps.manual_inputs.outputs.runtime_id }}" >> $GITHUB_OUTPUT
            echo "version=${{ steps.manual_inputs.outputs.version }}" >> $GITHUB_OUTPUT
            echo "pr_runtime_id=${{ steps.manual_inputs.outputs.pr_runtime_id }}" >> $GITHUB_OUTPUT
            echo "issue_number=${{ steps.manual_inputs.outputs.issue_number }}" >> $GITHUB_OUTPUT
            echo "trigger_type=Manual workflow dispatch" >> $GITHUB_OUTPUT
          fi
      
      - name: Lookup prod runtime
        id: get_runtime
        run: |
          # If runtime ID was provided from issue, use it directly
          if [ -n "${{ steps.inputs.outputs.runtime_id }}" ]; then
            RUNTIME_ID="${{ steps.inputs.outputs.runtime_id }}"
            echo "Using runtime ID from issue: ${RUNTIME_ID}"
          else
            # Otherwise, find prod runtime by name (for manual triggers without issue)
            RUNTIME_ID=$(python3 -c 'import boto3; client = boto3.client("bedrock-agentcore-control", region_name="us-west-2"); paginator = client.get_paginator("list_agent_runtimes"); result = [r["agentRuntimeId"] for page in paginator.paginate() for r in page.get("agentRuntimeSummaries", []) if r["agentRuntimeName"] == "prod"]; print(result[0] if result else "")' 2>&1)
            
            if [ -z "$RUNTIME_ID" ]; then
              echo "ERROR: Could not find prod runtime"
              exit 1
            fi
            echo "Found prod runtime by name lookup: ${RUNTIME_ID}"
          fi
          
          echo "runtime_id=${RUNTIME_ID}" >> $GITHUB_OUTPUT
      
      - name: Verify version exists
        id: verify_version
        run: |
          RUNTIME_ID="${{ steps.get_runtime.outputs.runtime_id }}"
          VERSION="${{ steps.inputs.outputs.version }}"
          
          # Get runtime details
          RUNTIME_JSON=$(aws bedrock-agentcore-control get-agent-runtime \
            --agent-runtime-id "${RUNTIME_ID}" \
            --region us-west-2)
          
          CURRENT_VERSION=$(echo "$RUNTIME_JSON" | jq -r '.agentRuntimeVersion')
          
          echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          
          # Verify requested version is not greater than current
          if [ "$VERSION" -gt "$CURRENT_VERSION" ]; then
            echo "ERROR: Requested version $VERSION does not exist. Current version is $CURRENT_VERSION"
            exit 1
          fi
          
          echo "‚úÖ Version $VERSION exists and is valid"
      
      - name: Check if prod endpoint exists
        id: check_endpoint
        run: |
          RUNTIME_ID="${{ steps.get_runtime.outputs.runtime_id }}"
          
          ENDPOINT_INFO=$(aws bedrock-agentcore-control get-agent-runtime-endpoint \
            --agent-runtime-id "${RUNTIME_ID}" \
            --endpoint-name prod \
            --region us-west-2 2>&1 || echo "NOT_FOUND")
          
          if echo "$ENDPOINT_INFO" | grep -q "NOT_FOUND\|ResourceNotFoundException"; then
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "current_version=none" >> $GITHUB_OUTPUT
            echo "No prod endpoint exists - will create"
          else
            echo "exists=true" >> $GITHUB_OUTPUT
            CURRENT_VERSION=$(echo "$ENDPOINT_INFO" | jq -r '.targetVersion')
            echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
            echo "Prod endpoint exists, currently at version ${CURRENT_VERSION}"
          fi
      
      - name: Create prod endpoint
        if: steps.check_endpoint.outputs.exists == 'false'
        id: create_endpoint
        run: |
          RUNTIME_ID="${{ steps.get_runtime.outputs.runtime_id }}"
          VERSION="${{ steps.inputs.outputs.version }}"
          
          echo "Creating prod endpoint for version ${VERSION}..."
          python3 create_endpoint.py "${RUNTIME_ID}" "${VERSION}" prod
          
          echo "‚úÖ Created prod endpoint pointing to version ${VERSION}"
      
      - name: Update prod endpoint
        if: steps.check_endpoint.outputs.exists == 'true'
        id: update_endpoint
        run: |
          RUNTIME_ID="${{ steps.get_runtime.outputs.runtime_id }}"
          VERSION="${{ steps.inputs.outputs.version }}"
          CURRENT_VERSION="${{ steps.check_endpoint.outputs.current_version }}"
          
          if [ "$VERSION" == "$CURRENT_VERSION" ]; then
            echo "‚ö†Ô∏è Prod endpoint is already at version ${VERSION}, no update needed"
            echo "updated=false" >> $GITHUB_OUTPUT
          else
            echo "Updating prod endpoint from version ${CURRENT_VERSION} to ${VERSION}..."
            python3 update_endpoint.py "${RUNTIME_ID}" prod "${VERSION}"
            echo "updated=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Updated prod endpoint to version ${VERSION}"
          fi
      
      - name: Cleanup PR runtime
        if: steps.inputs.outputs.pr_runtime_id != ''
        id: cleanup
        run: |
          PR_RUNTIME_ID="${{ steps.inputs.outputs.pr_runtime_id }}"
          echo "Cleaning up PR runtime: ${PR_RUNTIME_ID}"
          
          # Run cleanup script with auto-confirmation
          echo "DELETE" | python3 cleanup_runtime.py "${PR_RUNTIME_ID}"
          
          echo "cleaned_up=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Cleaned up PR runtime: ${PR_RUNTIME_ID}"
      
      - name: Get final state
        id: final_state
        run: |
          RUNTIME_ID="${{ steps.get_runtime.outputs.runtime_id }}"
          
          # Get endpoint info
          ENDPOINT_INFO=$(aws bedrock-agentcore-control get-agent-runtime-endpoint \
            --agent-runtime-id "${RUNTIME_ID}" \
            --endpoint-name prod \
            --region us-west-2)
          
          ENDPOINT_ARN=$(echo "$ENDPOINT_INFO" | jq -r '.agentRuntimeEndpointArn')
          TARGET_VERSION=$(echo "$ENDPOINT_INFO" | jq -r '.targetVersion')
          LIVE_VERSION=$(echo "$ENDPOINT_INFO" | jq -r '.liveVersion')
          STATUS=$(echo "$ENDPOINT_INFO" | jq -r '.status')
          
          echo "endpoint_arn=${ENDPOINT_ARN}" >> $GITHUB_OUTPUT
          echo "target_version=${TARGET_VERSION}" >> $GITHUB_OUTPUT
          echo "live_version=${LIVE_VERSION}" >> $GITHUB_OUTPUT
          echo "status=${STATUS}" >> $GITHUB_OUTPUT
      
      - name: Post promotion summary
        uses: actions/github-script@v7
        with:
          script: |
            const runtimeId = '${{ steps.get_runtime.outputs.runtime_id }}';
            const version = '${{ steps.inputs.outputs.version }}';
            const prRuntimeId = '${{ steps.inputs.outputs.pr_runtime_id }}';
            const issueNumber = '${{ steps.inputs.outputs.issue_number }}';
            const triggerType = '${{ steps.inputs.outputs.trigger_type }}';
            const endpointArn = '${{ steps.final_state.outputs.endpoint_arn }}';
            const targetVersion = '${{ steps.final_state.outputs.target_version }}';
            const liveVersion = '${{ steps.final_state.outputs.live_version }}';
            const status = '${{ steps.final_state.outputs.status }}';
            const wasUpdated = '${{ steps.update_endpoint.outputs.updated }}' !== 'false';
            const wasCleanedUp = '${{ steps.cleanup.outputs.cleaned_up }}' === 'true';
            const oldVersion = '${{ steps.check_endpoint.outputs.current_version }}';
            
            const statusEmoji = status === 'READY' ? '‚úÖ' : '‚è≥';
            
            let summary = `## ‚úÖ Production Promotion Complete\n\n`;
            summary += `Version **${version}** has been promoted to production!\n\n`;
            summary += `### üìã Promotion Details\n\n`;
            summary += `**Trigger**: ${triggerType}\n`;
            summary += `**Runtime ID**: \`${runtimeId}\`\n`;
            summary += `**Promoted Version**: ${version}\n`;
            summary += `**Previous Version**: ${oldVersion === 'none' ? 'N/A (first deployment)' : oldVersion}\n`;
            summary += `**Endpoint Status**: ${statusEmoji} ${status}\n`;
            summary += `**Target Version**: ${targetVersion}\n`;
            summary += `**Live Version**: ${liveVersion}\n`;
            
            if (prRuntimeId) {
              summary += `\n### üßπ Cleanup\n\n`;
              if (wasCleanedUp) {
                summary += `‚úÖ PR runtime (\`${prRuntimeId}\`) has been cleaned up\n`;
                summary += `- Runtime and endpoints deleted\n`;
                summary += `- S3 files preserved for audit\n`;
              } else {
                summary += `‚ö†Ô∏è PR runtime (\`${prRuntimeId}\`) cleanup failed\n`;
              }
            }
            
            summary += `\n### üîó Production Links\n\n`;
            summary += `- [View Runtime in AWS Console](https://us-west-2.console.aws.amazon.com/bedrock/home?region=us-west-2#/agent-runtimes/${runtimeId})\n`;
            summary += `- [CloudWatch Logs](https://us-west-2.console.aws.amazon.com/cloudwatch/home?region=us-west-2#logsV2:log-groups)\n`;
            summary += `- **Endpoint ARN**: \`${endpointArn}\`\n`;
            
            summary += `\n### üìä S3 Location\n`;
            summary += `\`\`\`\n`;
            summary += `s3://agentcore-runtime-pr-deployment-demo/prod/v${version}/code.zip\n`;
            summary += `\`\`\`\n`;
            
            // Post as workflow summary
            await core.summary
              .addRaw(summary)
              .write();
            
            // Update the deployment issue if we have an issue number
            if (issueNumber && issueNumber !== '') {
              const issueNum = parseInt(issueNumber);
              
              try {
                // Comment on the issue
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum,
                  body: `‚úÖ **Promoted to production**\n\n${summary}`
                });
                
                // Close and relabel the issue
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum,
                  state: 'closed',
                  labels: ['deployment', 'production', 'promoted']
                });
                
                console.log(`‚úÖ Updated and closed issue #${issueNum}`);
              } catch (error) {
                console.log(`‚ö†Ô∏è Could not update issue #${issueNum}: ${error.message}`);
              }
            } else {
              // Try to find issue by version if no issue number provided (backward compatibility)
              try {
                const { data: issues } = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  labels: 'needs-promotion',
                  state: 'open'
                });
                
                for (const issue of issues) {
                  if (issue.title.includes(`Version ${version}`)) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `‚úÖ **Promoted to production**\n\n${summary}`
                    });
                    
                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      state: 'closed',
                      labels: ['deployment', 'production', 'promoted']
                    });
                    
                    console.log(`‚úÖ Found and updated issue #${issue.number}`);
                    break;
                  }
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è Could not find/update deployment issue: ${error.message}`);
              }
            }
            
            console.log('‚úÖ Production promotion complete!');
